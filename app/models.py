from django import forms
from django.conf import settings
from django.core.validators import RegexValidator
from django.db import models
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from shutil import rmtree
import posixpath

def upload_path_handler(instance, old_filename):
    """Upload path handler for dynamic naming of folders for user uploads
    :param instance: BiomSearchJob instance of job
    :param old_filename: String old_filename
    :return: String the path to file upload for current user
    """
    old_filename = old_filename.split('.')
    name, ext = old_filename[0:-1], old_filename[-1]

    new_filename = "{uid}-{id}.{ext}".format(
        uid=instance.user_id, id=instance.pk, ext=ext
    )
    new_file_path = posixpath.join(
        str(instance.user_id),
        posixpath.join(str(instance.pk), new_filename)
    )
    return new_file_path


class Guest(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    status = models.BooleanField(default=False)

    def __unicode__(self):
        if self.status:
            return u"{uname} is a guest".format(uname=self.user.username)
        else:
            return u"{uname} is not a guest".format(uname=self.user.username)


class EcosystemChoice(models.Model):
    ecosystem = models.CharField(verbose_name="Ecosystem Type", max_length=60)
    ecosystem_proper_name = models.CharField(max_length=60)

    def __unicode__(self):
        return self.ecosystem_proper_name


class TaxonomyRankChoice(models.Model):
    taxon_rank = models.CharField(verbose_name="Taxonomy Chart Rank", max_length=60)
    taxon_rank_proper_name = models.CharField(max_length=60)

    def __unicode__(self):
        return self.taxon_rank_proper_name


class BiomSearchJob(models.Model):
    """Job status IDs"""
    STOPPED = -1
    VALIDATING = 0
    QUEUED = 1
    PROCESSING = 2
    RERUN = 3
    COMPLETED = 10

    STATUSES = (
        (STOPPED, "Stopped"),
        (QUEUED, "Queued"),
        (VALIDATING, "Validating"),
        (PROCESSING, "Processing"),
        (RERUN, "Re-running"),
        (COMPLETED, "Completed"),
    )

    """Analysis type IDs"""
    BRAYCURTIS = 1
    GNATUNIFRAC = 2
    AESAUNIFRAC = 3

    ANALYSISTYPES = (
        (BRAYCURTIS, "Bray Curtis"),
        (GNATUNIFRAC, "GNAT/UniFrac"),
        (AESAUNIFRAC, "AESA/UniFrac")
    )

    """Error type IDs"""
    FILE_IO_ERROR = -1
    NO_ERRORS = 0
    FILE_VALIDATION_ERROR = 1
    SAMPLE_COUNT_ERROR = 2
    DUPLICATE_ID_ERROR = 3
    OTU_NOT_EXIST = 4
    STRICT_GREENGENES_ID = 5
    UNKNOWN_ERROR = 6

    ERRORS = (
        (NO_ERRORS, "No errors."),
        (FILE_VALIDATION_ERROR,
         "File/text content has errors. Check JSON/TSV content."),
        (SAMPLE_COUNT_ERROR,
         "Too many user samples for that analysis type, please refer to the " +
         "help page for more information on maximum samples sizes"),
        (DUPLICATE_ID_ERROR,
         "Duplicate observation IDs."),
        (FILE_IO_ERROR,
         "Error opening uploaded file. Contact site admin."),
        (OTU_NOT_EXIST,
         "Some OTUs do not exist in the database. Check that the OTU IDs " +
         "are generated by GreenGenes using closed reference."),
        (STRICT_GREENGENES_ID,
         "Non-GreenGenes IDs detected. Please ensure your OTU IDs are " +
         "formatted as GreenGenes integers (i.e. 1991307) and not " +
         "prepended or appended by other strings " +
         "(i.e. OTU_1991307, 1991307OTU)."),
        (UNKNOWN_ERROR,
         "An error occurred. This may be a problem with the system. " +
         "Try again or contact site admin."),
    )

    """Range query value IDs"""
    NARROWEST = 0.1
    NARROWER = 0.2
    NORMAL = 0.3
    BROADER = 0.4
    BROADEST = 0.5

    RANGE_QUERY_VALUES = (
        (NARROWEST, "0.1"),
        (NARROWER, "0.2"),
        (NORMAL, "0.3"),
        (BROADER, "0.4"),
        (BROADEST, "0.5")
    )

    alphanumeric_spaces = RegexValidator(
        r"^[0-9a-zA-Z\s]*$", "Only alphanumeric characters and spaces allowed"
    )

    user = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="jobs"
    )
    biom_file = models.FileField(
        upload_to=upload_path_handler, null=True, blank=True
    )
    criteria = models.ManyToManyField(
        'EcosystemChoice', blank=False, max_length=3
    )
    taxonomy_ranks = models.ManyToManyField(
        'TaxonomyRankChoice', blank=False, max_length=3, default=["phylum", "family", "genus"]
    )
    name = models.CharField(
        null=False, blank=False, max_length=100, default="Unnamed Job",
        validators=[alphanumeric_spaces]
    )
    analysis_type = models.IntegerField(
        choices=ANALYSISTYPES, default=GNATUNIFRAC
    )
    range_query_value = models.FloatField(choices=RANGE_QUERY_VALUES, default=0.3)
    adaptive_rarefaction_flag = models.BooleanField(default=False)
    is_public = models.BooleanField(default=False)
    status = models.IntegerField(choices=STATUSES, default=VALIDATING)
    error_code = models.IntegerField(choices=ERRORS, default=NO_ERRORS)
    is_normalized_otu = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_run_at = models.DateTimeField(null=True)

    def __unicode__(self):
        return u"({}) by {} created at {}".format(
            self.name, self.user.username, self.created_at
        )

    def file_safe_name(self):
        return self.name.replace(" ", "_")

    def delete(self, *args, **kwargs):
        """Overridden delete function to delete uploaded and processed
        files when jobs are deleted. Comment this function out to keep
        user uploaded files and other processed files when jobs are
        deleted.
        """
        job_folder = posixpath.join(
            str(self.user_id), str(self.pk)
        )
        rmtree(posixpath.join(settings.MEDIA_ROOT, job_folder))
        super(BiomSearchJob, self).delete(*args, **kwargs)

    def save(self, *args, **kwargs):
        if self.pk is None and self.biom_file.name is not None:
            saved_file = self.biom_file
            self.biom_file = None
            super(BiomSearchJob, self).save(*args, **kwargs)
            self.biom_file = saved_file

        super(BiomSearchJob, self).save(*args, **kwargs)


class BiomSample(models.Model):
    name = models.CharField(max_length=100)
    job = models.ForeignKey(
        BiomSearchJob, on_delete=models.CASCADE, related_name="samples"
    )

    def __unicode__(self):
        return self.name


class BiomSearchForm(forms.ModelForm):
    """The homepage form structure which has a text area, file upload and a set
    of checkboxes for the selection criteria
    """
    class Meta:
        model = BiomSearchJob
        fields = {
            "name": forms.CharField,
            "biom_file": forms.FileField,
            "criteria": forms.MultipleChoiceField(required=True),
            "is_normalized_otu": forms.BooleanField(required=False),
            "adaptive_rarefaction_flag": forms.BooleanField(required=False),
            "is_public": forms.BooleanField(required=False),
            "analysis_type": forms.ChoiceField(required=True),
            "range_query_value": forms.ChoiceField,
            "taxonomy_ranks": forms.MultipleChoiceField(required=True),
        }
        labels = {
            "criteria": "Select the ecosystem(s)",
            "is_normalized_otu":
                "I have normalized the 16S OTU copy numbers for this BIOM table",
            "adaptive_rarefaction_flag":
                "Perform adaptive rarefaction on my samples",
            "is_public": "Make public",
        }
        help_texts = {
            "criteria": "Selecter either the 'All' criteria or a maximum of 3 ecosystems",
            "is_normalized_otu": "Optional but recommended if you are not sure",
            "adaptive_rarefaction_flag": "Optional",
            "range_query_value": "Only applies to GNAT/UniFrac",
            "taxonomy_ranks": "Select maximum of three taxonomy level charts (GNAT search only)",
        }
        widgets = {
            "criteria": forms.CheckboxSelectMultiple,
            "taxonomy_ranks": forms.CheckboxSelectMultiple,
            "name": forms.TextInput(
                attrs={
                    "placeholder": "Name this job",
                    "class": "form-control"
                }
            )
        }

    biom_file = forms.FileField(
        label="or upload your BIOM or FASTA file",
        help_text="Max. 10 samples for GNAT/UniFrac, 100 samples for AESA/UniFrac & Bray-Curtis",
        required=False,
    )

    otu_text_attrs = {
        "cols": 30,
        "rows": 5,
        "placeholder": "Paste OTU table here"
    }
    otu_text = forms.CharField(
        label="Paste your OTU table",
        help_text="Max. 10 samples for GNAT/UniFrac, 100 samples for AESA/UniFrac & Bray-Curtis",
        widget=forms.Textarea(attrs=otu_text_attrs),
        required=False
    )

    def _empty_otu_text(self, otu_text):
        """
        Checks the validity of the OTU text in the textarea

        :param otu_text: String OTU table in text format
        :return: Boolean truth value of the check
        """
        # if the box is empty
        if otu_text is None or otu_text == "":
            return True
        # otherwise
        return False

    def clean(self):
        """Microbiome search form validation. Checks for chosen criteria and if
        both BIOM and OTU texts are uploaded properly

        :return: Boolean truth value of the check
        """
        # check if OTU table is empty
        try:
            otu_text = self.cleaned_data["otu_text"]
        except KeyError:
            otu_text = None

        # check if criteria is empty
        try:
            criteria = self.cleaned_data["criteria"]
        except KeyError:
            criteria = []

        try:
            biom_file = self.cleaned_data["biom_file"]
        except KeyError:
            biom_file = None

        # if number of criteria chosen is more than 3
        if len(criteria) > 3:
            msg = forms.ValidationError(
                "Maximum of 3 criteria allowed or all criteria"
            )
            self.add_error("criteria", msg)

        # if number of criteria chosen is 0
        if len(criteria) == 0:
            msg = forms.ValidationError(
                "At least one criteria must be selected"
            )
            self.add_error("criteria", msg)

        # if BIOM file or OTU text is not filled in or submitted
        if self._empty_otu_text(otu_text) and biom_file is None:
            msg = forms.ValidationError(
                "An upload of the OTU table or BIOM file is required"
            )
            self.add_error("biom_file", msg)
            self.add_error("otu_text", msg)

        # if BIOM file and OTU text is both filled in or submitted
        if not self._empty_otu_text(otu_text) and biom_file is not None:
            msg = forms.ValidationError(
                "Only upload the OTU table or BIOM file and not both"
            )
            self.add_error("biom_file", msg)
            self.add_error("otu_text", msg)

        return self.cleaned_data


class UserForm(forms.ModelForm):
    """General User form for registration and update details"""
    class Meta:
        model = User
        fields = [
            "username",
            "email",
            "password",
            "confirm",
        ]
        labels = {
            "email": "Email",
        }
        widgets = {
            "password": forms.PasswordInput,
            "username": forms.TextInput(attrs={'placeholder': 'Username'}),
            "email": forms.EmailInput(
                attrs={'placeholder': 'example@email.com'}),
        }

    confirm = forms.CharField(
        widget=forms.PasswordInput,
        label="Confirm Password",
    )

    def clean_confirm(self):
        password = self.cleaned_data.get("password")
        confirm = self.cleaned_data.get("confirm")
        if password and confirm and password != confirm:
            msg = forms.ValidationError("Passwords must match")
            self.add_error("password", msg)
            self.add_error("confirm", msg)
